<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://letjs.dev</id>
    <title>Let&apos;s Javascript</title>
    <updated>2019-08-19T03:30:33.228Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://letjs.dev"/>
    <link rel="self" href="https://letjs.dev/atom.xml"/>
    <subtitle>&lt;a href=&quot;https://github.com/webszy/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot; target=&quot;_blank&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot;  aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;</subtitle>
    <logo>https://letjs.dev/images/avatar.png</logo>
    <icon>https://letjs.dev/favicon.ico</icon>
    <rights>All rights reserved 2019, Let&apos;s Javascript</rights>
    <entry>
        <title type="html"><![CDATA[入门级多语言配置]]></title>
        <id>https://letjs.dev/post/ru-men-ji-duo-yu-yan-pei-zhi</id>
        <link href="https://letjs.dev/post/ru-men-ji-duo-yu-yan-pei-zhi">
        </link>
        <updated>2019-08-14T07:37:25.000Z</updated>
        <summary type="html"><![CDATA[<p>这个系列主要是记录一下最近研究的多语言配置，主要供新手学习使用，大牛可以不用看了</p>
]]></summary>
        <content type="html"><![CDATA[<p>这个系列主要是记录一下最近研究的多语言配置，主要供新手学习使用，大牛可以不用看了</p>
<!-- more -->
<h2 id="目录">目录</h2>
<ul>
<li><a href="#jquery">JQuery实现</a></li>
<li><a href="#vue1">简单的Vue实现</a> 没有切换语言功能</li>
</ul>
<h2 id='jquery'>JQuery实现</h2>
<blockquote>
<p>懒得看的同学可以直接 <a href="https://github.com/webszy/simple-translate">点这里</a></p>
</blockquote>
<h4 id="基本思路">基本思路</h4>
<ul>
<li>布局时就给需要多语言的标签加个属性</li>
<li>通过同步的ajax引入语言包</li>
<li>判断用户语言类型</li>
<li>循环遍历DOM,修改innerHTML</li>
</ul>
<h4 id="布局准备">布局准备</h4>
<pre><code class="language-HTML">    &lt;h2 data-lang data-lang-id=&quot;title&quot;&gt;simple Translation&lt;/h2&gt;
</code></pre>
<h4 id="引入语言包">引入语言包</h4>
<pre><code class="language-JS">function loadDict() {
    $.ajax({
        type: &quot;get&quot;,
        url: &quot;./language.json&quot;,
        dataType: &quot;json&quot;,
        async: false, //同步加载文件
        success: function(response) {
            window.langData = response //挂载到全局对象下
        }
    });

}
</code></pre>
<p>简单的语言包模板</p>
<pre><code class="language-JS">[{
        &quot;ID&quot;: &quot;title&quot;,
        &quot;Chinese&quot;: &quot;simple Translation&quot;,
        &quot;English&quot;: &quot;simple Translation&quot;
    },
    {
        &quot;ID&quot;: &quot;content&quot;,
        &quot;Chinese&quot;: &quot;这是一个简单的页面翻译工具，或者叫国际化工具。主要功能就是为网站提供多语言支持&quot;,
        &quot;English&quot;: &quot;This is exmple page for simple Translation which a simple tools to translate your web Page&quot;
    },
    {
        &quot;ID&quot;: &quot;li1&quot;,
        &quot;Chinese&quot;: &quot;使用简单&quot;,
        &quot;English&quot;: &quot;easy to use and learn&quot;
    }]
</code></pre>
<h4 id="判断用户语言类型">判断用户语言类型</h4>
<pre><code class="language-JS">//传入langCode，实现用户可以自己切换语言
function getUserLanguage(langCode) {
    var lang = navigator.language || navigator.userLanguage;
    var result = langCode ? langCode : lang.toLocaleLowerCase().substr(0, 2);
    //这里可以根据你的语言包自己自定义
    var obj = {
        &quot;zh&quot;: &quot;Chinese&quot;,
        &quot;en&quot;: &quot;English&quot;,
        &quot;de&quot;: &quot;Germany&quot;,
        &quot;ru&quot;: &quot;Russia&quot;,
        &quot;fr&quot;: &quot;France&quot;,
        &quot;ko&quot;: &quot;Korea&quot;,
        &quot;pt&quot;: &quot;Portague&quot;,
        &quot;ja&quot;: &quot;Japanese&quot;,
        &quot;es&quot;: &quot;Spanish&quot;,
        &quot;it&quot;: &quot;Italy&quot;
    }

    return !obj[result] ? &quot;Chinese&quot; : obj[result]
}
</code></pre>
<h4 id="循环遍历dom">循环遍历DOM</h4>
<pre><code class="language-JS">function translate(langCode) {
    var lang = getUserLanguage(langCode),
        dict = window.langData,
        len = window.langData.length
    $('[data-lang]').each(function() {
        var id = $(this).attr('data-lang-id'),
            tag = this.tagName.toLowerCase()
        for (var i = 0; i &lt; len; i++) {
            console.log(dict[i][lang])
            if (dict[i]['ID'] == id) {
                if (dict[i][lang] == null) { break }
                if (tag == 'input') { $(this).val(dict[i][lang]); break; }
                $(this).html(dict[i][lang])
            }
        }
    });
}
</code></pre>
<p>这里应该都能看懂，唯一容易出问题的地方就是同步加载语言那里，我使用了JQuery 1.8.3,是支持同步的，如果不支持，你可以把改成原生ajax或者干脆改成一个js文件</p>
<h2 id='vue1'>Vue的简单实现</h2>
<blockquote>
<p>由于目前需要的功能还没有切换语言，所以写了一个一次性改变语言的功能</p>
</blockquote>
<h3 id="基本思路-2">基本思路</h3>
<ul>
<li>准备语言包JS</li>
<li>在main.js里引入，判断语言，同时挂载到Vue对象下</li>
<li>在各个组件中直接调取</li>
</ul>
<h3 id="准备语言包">准备语言包</h3>
<blockquote>
<p>还是不喜欢用json格式，因为ajax请求总是异步的，不好控制<br>
我用了这个模板</p>
</blockquote>
<pre><code class="language-JS"> const lang={
  //中文简体
  zhj:{
    tabBar:{//底栏
      a:&quot;获得粉丝&quot;,
      b:&quot;获得点赞&quot;,
      c:&quot;购买VIP&quot;,
      d:&quot;更多&quot;
    }
   }
  }
  export default lang
</code></pre>
<h3 id="引入并加载">引入并加载</h3>
<p>引入很简单<code>import lang from './assets/js/lang'</code><br>
然后，我把它挂载到了根Vue对象中</p>
<pre><code class="language-JS">new Vue({
  el: '#app',
  router,
  components: { App },
  render:h =&gt; h(App),
  created() {
    // 载入多语言
    this._intiLang()
  },
  data(){
    return{
      lang:{}
    }
  },
  methods: {
    getUserLang(){ //获取用户语言
      var lang = navigator.language||navigator.userLanguage;
      var result=lang.toLocaleLowerCase().substr(0,2);
      if(result=='zh'){
          if(lang.toLocaleLowerCase()=='zh-cn'){//中文简体
              result=&quot;zhj&quot;
          }else{
              result=&quot;zhf&quot; //中文繁体
          }
      }
      return result
    },
    _intiLang(){
      let langName=this.getUserLang()
      let data = lang[langName] ?  lang.en : lang[langName]
      this.lang=data
    },
    changeLang(type){ //提取多语言的内容
      return !this.lang[type]?'lang':this.lang[type]
    }
  },
})

</code></pre>
<h3 id="子组件中调用">子组件中调用</h3>
<pre><code class="language-Vue">&lt;template&gt;
    &lt;p&gt;tabBarName.a&lt;/p&gt;
    &lt;p&gt;tabBarName.b&lt;/p&gt;
    &lt;p&gt;tabBarName.c&lt;/p&gt;
    &lt;p&gt;tabBarName.d&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'Gfooter',
  data () {
    return {
      tabBarName:this.$root.changeLang('tabBar')
     }
    }
  }
 &lt;/script&gt;
</code></pre>
<blockquote>
<p>这样就实现了一个简单的多语言，在子组件中只要通过<code>this.$root.changeLang()</code>这个函数来取值就行了。当然这个方法还有很多不足，适用面也很窄。下一步准备去研究i18n,如果抽得出时间，我打算自己写一个vue插件</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录优化Vue-Cli的那些事1（入门级）]]></title>
        <id>https://letjs.dev/post/ji-lu-you-hua-vue-cli-de-na-xie-shi-1ru-men-ji</id>
        <link href="https://letjs.dev/post/ji-lu-you-hua-vue-cli-de-na-xie-shi-1ru-men-ji">
        </link>
        <updated>2019-08-14T07:35:15.000Z</updated>
        <summary type="html"><![CDATA[<p>最近新作的一个H5 webApp的首页加载速度简直慢到发指，所以才打算优化一下，暂时先写一些入门级的优化。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近新作的一个H5 webApp的首页加载速度简直慢到发指，所以才打算优化一下，暂时先写一些入门级的优化。</p>
<!-- more -->
<p>首先先看一下优化前的情况，通过webpack-bundle-analyzer可以很直观的看出来，当前打包情况。在2.x的脚手架中,可以直接通过<br>
<code>npm run build --report</code>来查看，3.x则需要安装插件</p>
<h3 id="1-升级脚手架版本">1、升级脚手架版本</h3>
<p>我之前还是使用的Vue-cli2.x的模板搭建的，我发现升级为3.x的确实能够显著提升速度，估计是因为webpack版本也升级了。</p>
<ul>
<li>注意图片路径问题以及组件路径问题</li>
</ul>
<blockquote>
<p>之前放到static文件夹下的图片，直接写相对路径即可。例如<code>'../../static/images/1.png'</code>=&gt;<code>'images/1.png'</code>,组件路径同理。</p>
</blockquote>
<ul>
<li>路由懒加载写法变化。</li>
</ul>
<blockquote>
<p>之前我都是直接这样写<code>component: resolve =&gt; require(['../views/followers/index.vue'], resolve)</code>，现在貌似可以直接import了<code>()=&gt;{import '../views/followers/index.vue'}</code></p>
</blockquote>
<h3 id="2-cdn引入">2、cdn引入</h3>
<blockquote>
<p>其实在2.x的脚手架中已经实现了分开打包，app.js主要是业务代码，vendor.js则是第三方库。但是打包出来vendor.js还是过大。如何再拆分vendor还在继续研究中。目前我暂时使用cdn来解决,个人建议使用jsdelivr，速度不错。之后在webpack.base.conf.js中加入如下代码</p>
</blockquote>
<pre><code>    externals: {
        'mint-ui': 'MINT',
        'vue': 'Vue',
        'vue-router': 'VueRouter',
        'axios': 'axios',
    }
</code></pre>
<p>PS.需要注意吧cdn引入的js标签放到#app上面<br>
PS.. 注意引用的webpack中填写的名字应是挂载在window对象下的名字</p>
<h3 id="3-优化图片">3、优化图片</h3>
<p>优先使用字体小图标、纯css,css背景图或精灵图，尽量把图片放到assets目录中(可以直接压缩).</p>
<blockquote>
<p>展望后续：DLLPlugin的使用，vendor继续拆分，css拆分</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[axios封装指南]]></title>
        <id>https://letjs.dev/post/axios-feng-zhuang-zhi-nan</id>
        <link href="https://letjs.dev/post/axios-feng-zhuang-zhi-nan">
        </link>
        <updated>2019-08-14T07:32:32.000Z</updated>
        <summary type="html"><![CDATA[<p>在vue中最常用的应该就是axios了，这是一个很强大的处理ajax的库。今天我就分享一下我是如何封装axios的。axios的基本api不再赘述，提前安装一下也不用我说了吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>在vue中最常用的应该就是axios了，这是一个很强大的处理ajax的库。今天我就分享一下我是如何封装axios的。axios的基本api不再赘述，提前安装一下也不用我说了吧</p>
<!-- more -->
<h2 id="第一步配置axios">第一步：配置axios</h2>
<ul>
<li>首先，创建一个<code>Service.js</code>，这里面存放的时axios的配置以及拦截器等，最后导出一个axios对象。我平常elementUI用的比较多，这里你也可以使用自己的UI库。</li>
</ul>
<pre><code class="language-javascript">import axios from 'axios'
import { Message, Loading } from 'element-ui'
const ConfigBaseURL = 'https://localhost:3000/' //默认路径，这里也可以使用env来判断环境
let loadingInstance = null //这里是loading
//使用create方法创建axios实例
export const Service = axios.create({
  timeout: 7000, // 请求超时时间
  baseURL: ConfigBaseURL,
  method: 'post',
  headers: {
    'Content-Type': 'application/json;charset=UTF-8'
  }
})
// 添加请求拦截器
Service.interceptors.request.use(config =&gt; {
  loadingInstance = Loading.service({
    lock: true,
    text: 'loading...'
  })
  return config
})
// 添加响应拦截器
Service.interceptors.response.use(response =&gt; {
  loadingInstance.close()
  // console.log(response)
  return response.data
}, error =&gt; {
  console.log('TCL: error', error)
  const msg = error.Message !== undefined ? error.Message : ''
  Message({
    message: '网络错误' + msg,
    type: 'error',
    duration: 3 * 1000
  })
  loadingInstance.close()
  return Promise.reject(error)
})
</code></pre>
<blockquote>
<p>具体的拦截器逻辑以具体业务为准，我这里没什么逻辑，只是加了一个全局的loading而已</p>
</blockquote>
<h2 id="第二步封装请求">第二步：封装请求</h2>
<blockquote>
<p>这里我再创建一个<code>request.js</code>,这里面放的是具体请求。</p>
</blockquote>
<pre><code class="language-javascript">import {Service} from './Service'
export function getConfigsByProductId(productId) {
  return Service({
    url: '/manager/getConfigsByProductId',
    params: { productId: productId }
  })
}
export function getAllAndroidPlugins() {
  return Service({
    url: '/manager/getAndroidPlugin ',
    method: 'get'
  })
}
export function addNewAndroidPlugin(data) {
  return Service({
    url: '/manager/addAndroidPlguin',
    data: JSON.stringify(data)
  })
}
</code></pre>
<p>当然你也可以url再封装一遍，放到另一个文件里，我觉得这样并无什么意义，反而增加复杂度。这里主要注意的是起名问题，建议按功能起名，例如我这里<code>请求方式+功能或者内容+参数</code>,这样子直接看<code>getConfigsByProductId</code>这个名字也是很清晰明了</p>
<h2 id="第三步使用">第三步：使用</h2>
<p>在vue组件中</p>
<pre><code>import {getAllAndroidPlugins,getConfigsByProductId,addNewAndroidPlugin} from '@/api/request.js'

getAllAndroidPlugins()
.then(res=&gt;{

})
</code></pre>
<p>全局使用 在main.js中</p>
<pre><code>import {Service} from '@/api/Service.js'
Vue.prototype.$axios=Service

</code></pre>
<hr>
<blockquote>
<p>欢迎指正与交流</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过userAgent切换访问地址的3种方法]]></title>
        <id>https://letjs.dev/post/tong-guo-useragent-qie-huan-fang-wen-di-zhi-de-3-chong-fang-fa</id>
        <link href="https://letjs.dev/post/tong-guo-useragent-qie-huan-fang-wen-di-zhi-de-3-chong-fang-fa">
        </link>
        <updated>2019-08-14T07:16:36.000Z</updated>
        <summary type="html"><![CDATA[<p>现实中经常会碰到根据游览器或者设备，或者系统去访问不同的网页。再此，我总结了3种常用的方法，供大家参考。</p>
]]></summary>
        <content type="html"><![CDATA[<p>现实中经常会碰到根据游览器或者设备，或者系统去访问不同的网页。再此，我总结了3种常用的方法，供大家参考。</p>
<!-- more -->
<h3 id="第一种通过js">第一种：通过JS</h3>
<pre><code>var ua = window.userAgent || navigator.userAgent;
if(ua.toLowerCase().indexOf('android')&gt;=0){
    window.location.href=&quot;https://google.com&quot;
}else if(ua.toLocaleLowerCase().indexOf(&quot;iphone&quot;) &gt;= 0){
    window.location.href=&quot;https://apple.com&quot;
}else if(ua.toLocaleLowerCase().indexOf(&quot;mac&quot;) &gt;= 0){
    //此处省略
}
</code></pre>
<p>建议将改js放置head标签中，以便尽快执行。</p>
<h3 id="第二种通过nginx配置">第二种：通过nginx配置</h3>
<pre><code>server {
       listen 80;
       listen       443 ssl;
        ssl_certificate /opt/certs/vip/vip_bundle.crt;
	ssl_certificate_key /opt/certs/vip/vip.key;
       server_name www.vip.vip vip.vip;
       access_log  logs/vip_access.log  main;
       error_log   logs/vip_error.log;
       location / {
          root /opt/wwwroot/app;
          try_files $uri $uri.html $uri/ =404;
          index index.html index.htm;
       }
       # 这里就是根据userAgent去判断
       location /geek {
         if ($http_user_agent ~* &quot;Android&quot;) {
            root /opt/wwwroot/app/andorid;
            break ;
	      }
         if ($http_user_agent ~* &quot;(iPhone|iPad)&quot;) {
            root /opt/wwwroot/app/ios;
            break ;
	      }
         rewrite ^/(.*) https://geek.vip redirect;
       }
}
</code></pre>
<h3 id="第三种-通过后台路由">第三种 通过后台路由</h3>
<p>这里是因为我要做一个下载链接，当安卓时直接返回apk,当ios时则返回appstore的地址,我使用了express</p>
<pre><code>app.get('/api/xz',(req, res) =&gt; {
    let userAgent=req.headers['user-agent']
    //判断是否是搜索引擎爬虫访问
    if(isRobot(userAgent)){
        res.status(200)
        return
    }else{
        let key=req.query.key||'vip'
        let json=JSON.parse(fs.readFileSync(path.join(__dirname,'./redirectList.json'))),
        switchInfo={},exists=false
        for(let k of json){
            if(k.key===key){
                switchInfo=k
                exists=true
            }
        }
        if(!exists){ 
            res.status(404)
            return
        }
        
        let system=userSystem(userAgent)
        res.redirect(switchInfo[system])
    }
})
//判断是否是搜索引擎
function isRobot(userAgent){
    let RobotList='qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo! Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot|FeedDemon|JikeSpider|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|YisouSpider|HttpClient|MJ12bot|heritrix|EasouSpider|Ezooms'
    return RobotList.split('|').every(k=&gt;{
        return userAgent.indexOf(k)&gt;-1
    })
}
//判断用户系统类型
function userSystem(userAgent){
   let ua=userAgent.toLowerCase()
   if(ua.indexOf('android')&gt;=0){
       return 'android'
   }else if(ua.indexOf('ios')&gt;=0||ua.indexOf('ipad')&gt;=0||ua.indexOf('mac')&gt;=0){
        return 'ios'
   }else{
       return 'other'
   }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端docker入门]]></title>
        <id>https://letjs.dev/post/qian-duan-docker-ru-men</id>
        <link href="https://letjs.dev/post/qian-duan-docker-ru-men">
        </link>
        <updated>2019-08-13T13:32:45.000Z</updated>
        <summary type="html"><![CDATA[<p>公司要求服务都以docker形式部署，虽然我的页面大部分都是静态页面，但是这次用nuxt做的ssr就是一个服务，所以也需要docker部署，研究了一番，总结一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>公司要求服务都以docker形式部署，虽然我的页面大部分都是静态页面，但是这次用nuxt做的ssr就是一个服务，所以也需要docker部署，研究了一番，总结一下。</p>
<!-- more -->
<h3 id="第一步安装pm2">第一步，安装pm2</h3>
<p>PM2这个神器不多说了，总之不装就等着服务老关吧，还找不到原因。</p>
<pre><code>npm i pm2 -g
pm2 init
</code></pre>
<p>运行完成后，会在项目下生成一个<code>ecosystem.config.js</code>,这个是pm2的配置文件。</p>
<pre><code>module.exports = {
  apps : [{
    name: 'pc_ssr',
    script: 'npm start', //主要改这里，这里是启动服务的命令

    // Options reference: https://pm2.io/doc/en/runtime/reference/ecosystem-file/
    args: 'one two',
    instances: 1,
    autorestart: true,
    watch: false,
    max_memory_restart: '1G',
    env: {
      NODE_ENV: 'production'
    },
    env_production: {
      NODE_ENV: 'production'
    }
  }]
};
</code></pre>
<h3 id="第二步编写dockerfile">第二步，编写Dockerfile</h3>
<p>dockerfile相当于docker的配置文件，当前这份文件基本就可以部署nuxt了，如果是其他静态页面，建议加上nginx.<br>
参考了 <a href="https://pm2.io/doc/zh/runtime/integration/docker/">PM2 的官方文档</a></p>
<pre><code>FROM  keymetrics/pm2:latest-alpine
ENV NODE_ENV=production
ENV HOST 0.0.0.0 

WORKDIR /usr/src/app
COPY . .

ENV NPM_CONFIG_LOGLEVEL warn
RUN npm install
RUN npm run build
EXPOSE 3000
CMD [ &quot;pm2-runtime&quot;, &quot;start&quot;, &quot;ecosystem.config.js&quot; ]

</code></pre>
<h3 id="第三步部署">第三步，部署</h3>
<p>首先服务器需要安装docker环境，这个不用我说了吧。<br>
如果把文件上传到服务器，也不用我说了吧！<br>
pc_ssr是我的项目名，你可以自己替换</p>
<pre><code>//生成映像
sudo docker build -t pc_ssr.
//运行这个映像
sudo  docker run -p 8085:3000 -d --restart=always  pc_ssr
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hello js world]]></title>
        <id>https://letjs.dev/post/hello-js-world</id>
        <link href="https://letjs.dev/post/hello-js-world">
        </link>
        <updated>2019-08-12T14:58:07.000Z</updated>
        <content type="html"><![CDATA[<p>我来了，我看到，我征服js<img src="https://letjs.dev/post-images/1565623045666.jpeg" alt=""></p>
]]></content>
    </entry>
</feed>